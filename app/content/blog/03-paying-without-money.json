{
  "publishedAt": "31st May 2020",
  "title": "03 - Paying without money",
  "tag": "Java Concepts",
  "content": "Considering the unfortunate event that took flight a few months ago and forced us to stay in our homes, each interaction with the outside world started to feel like a blessing.\r\n\r\nOr, at least, like something pretty important.   \r\n\r\nEven though I'm not the most passionate outgoer and I would describe myself as mildly introverted, I started to appreciate and to observe more the small things I do when I'm out. In the last months, this was strictly reduced to the weekly trips I took to the market.\r\n\r\nHere, the most complex action one could take, besides finding a product that vanished from its usual place, is paying.  \r\n\r\nAnd this is where the fun began.   \r\n\r\n#\r\n<div class=\"text-center\">\r\n    <img src='https://images.pexels.com/photos/3907161/pexels-photo-3907161.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940' description='Paying with Card Picture' alt='Paying with Card Picture' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Photo by <a href='https://www.pexels.com/@olly'>Andrea Piacquadio</a></p>\r\n</div>\r\n\r\n#\r\nLike many of us, I started dumping cash a few years ago and I paid almost exclusively with one of my cards. I'm not gonna lie, sometimes I was a little curious about how the transaction is executed, but I was not curious enough to dig deeper.  \r\n\r\nRecently, as a part of my master's degree, I had a course focused on E-payment security. Besides theory, the practical approach included an interesting section about smart card programming, specifically Java Smart Cards, and some questions I never thought I had started to receive answers.  \r\n\r\nFrom a programming point of view, smart card programming is way more niched than web app development or, more recently, neural networks, but I think the subject is suitable enough for an article.   \r\n\r\nIf you think the same, let's give it a shot!  \r\n\r\n# \r\n### The computer in your wallet\r\nYou've probably intuited that the smart card you're using every day to buy goodies is more of a computer than a dumb piece of plastic. This is true, but more than this, there are three main categories of smart cards, each being used in a different context. It's safe to say, though, that none is just a piece of plastic.  \r\n* Integrated Circuit Memory Cards - have a small amount of rewritable memory, but no processor to manipulate it, being dependent, in terms of computation, to a card reader - they are typically used in scenarios which require a fixed operation and are discarded afterward, like the one-time pre-paid cards in public phones\r\n* Optical Memory Cards - are similar to CDs in terms of looks and capacity, having a fair amount of memory which can be written only once and, just like the previous cards, don't have a processor - they are used to store records that shouldn't be altered (nope, I haven't seen one IRL either)  \r\n* Integrated Circuit Microprocessor Cards - are the actual type of cards we're familiar with - they have a microprocessor, rewritable memory and are used everywhere as they can store information, but also execute impressive operations when they are powered up  \r\n\r\n#\r\n<div class=\"text-center\">\r\n    <img src='https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/SmartCardPinout.svg/852px-SmartCardPinout.svg.png' description='Card Pins' alt='Card Pins' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Published on Wikipedia</a></p>\r\n</div>\r\n\r\nThe component that gives a card its \"smart\" prefix is the integrated circuit pictured above. If you've played with a Raspberry Pi before, you've already seen some of this acronyms, but we'll review them fast, to understand better how each pin helps the card to gain its capabilities:  \r\n* VCC - represents the power supply that boots up the card's chip\r\n* RST - resets the card in a \"gentle\" way (the alternative would be to switch the power off and on)\r\n* CLK - provides an external clock signal which is used to derive the chip's internal clock (microchips don't have an internal clock, unlike a normal-sized computer)\r\n* GND - the grounding pin\r\n* VPP - was used in older cards to directly program the persistent memory storage\r\n* I/O - is responsible for sending and receiving data, thus allowing basic input/output operations\r\n* C4/C8 - historically called RFUs, \"Reserved for future use\", are commonly used by the USB interfaces  \r\n\r\nBesides processing power, the microchip also contains a fair amount of memory used for storing data.  \r\n\r\nThe first type is the read-only memory which contains firmware that helps the card to function properly, followed by EEPROM and random access memory which, unlike ROM, can be written and rewritten many times.  \r\n\r\nThe difference between RAM and EEPROM is, in a way, like the difference between a computer's RAM and its memory disk. EEPROM is non-volatile, keeping its state after the card was disconnected from a power source, while RAM is, well, RAM and it's wiped each time the microchip restarts.  \r\n\r\nThe impressive capacity of a few kilobytes that a smart card can store doesn't seem stunning at all, but if we don't forget the type of activities a smartcard is used for, it's more than decent.  \r\nSadly, it cannot run Minecraft just yet, but for a price that, according to Oracle, varies between [7$ and 15$](https://www.oracle.com/technetwork/java/embedded/javacard/documentation/smartcards-136372.html), they do a great job at keeping our money safe.  \r\n\r\nThe details above are generic and describe a basic smartcard, but, like normal computers, they come in different flavors and can have more or fewer features, depending on many factors.\r\n\r\nOracle, *the* Oracle you're familiar with, is the biggest player in this niche, as Java is their most renowned *adoptive* child.  \r\n\r\nBesides Java Cards, which are the norm based on popularity and rate of adoption, another fairly popular smart card implementation is the C-based MultOS.  \r\n\r\nAlso, respecting the tradition of *Java vs C#*, a .NET-based smartcard runtime was prepared to take off, but the price of the final package turned out to be too high to facilitate its mass adoption.  \r\n\r\n#\r\n### WORA once again\r\nToday, Java Cards are everywhere.  \r\n\r\nStarting from 2015, more than 5 billion cards were produced each year. Each year! The \"3 billion devices\" meme really needs an update!  \r\n\r\nIn any case, Java's WORA approach hit the jackpot once again and, even though the number of bank emitted cards cannot be neglected, the omnipresent SIM was the golden ticket to the spikes in popularity Java Card have seen.  \r\n\r\nThis thing was possible when the European Telecommunications Standards Institute, in the attempt to create a global standard as an alternative to proprietary implementations that were existing before, chose a Java-based stack.    \r\n\r\nAfter that, many companies joined forces and created GlobalPlatform, a coordinated effort meant to develop universal specifications. Following in Java's *\"Write Once Run Anywhere\"* footsteps, GlobalPlatform's credo was resumed as *\"Develop once and deploy anywhere\"*.  \r\n\r\nFrom a technical perspective, the Java Card Platform, which hit its 3.1 version in 2018, is represented by a stripped-down version of Java which removes some high-level features available in the standard edition but provides other APIs focused on the common tasks a smartcard should accomplish.  \r\n\r\nTo accommodate the changes that were required by the new minimal environment, the Java Card Virtual Machine was defined, along with the Java Card Runtime Environment and the [Java Card API](https://docs.oracle.com/en/java/javacard/3.1/jc_api_srvc/api_classic/index.html) which shifted the focus of the entire platform to security and reliability.  \r\n\r\nThe [official docs](https://docs.oracle.com/en/java/javacard/3.1/guide/preface.html#GUID-07C116D2-4E9D-43CB-99CF-D79DC46C077A) cover a marvelous explanation of how the whole platform works and offers a lot of well structured first steps examples. If this subject already caught your attention, you should definitely check them out!  \r\n\r\n#\r\n<div class=\"text-center\">\r\n    <img style='margin:0 auto' src='https://images.unsplash.com/photo-1556742031-c6961e8560b0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=400&q=80' description='Buying Coffee Picture' alt='Buying Coffee Picture' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Photo by <a href='https://unsplash.com/@claybanks'>Clay Banks</a></p>\r\n</div>\r\n\r\n#\r\n### JCRE Anatomy\r\n[The architecture of a Java Card](https://docs.oracle.com/en/java/javacard/3.1/guide/java-card-3-platform-architecture.html) follows the same minimal approach as the language itself. On top of the hardware, sits the Java Card OpenPlatform OS which manages each operation. Using the OS' available system calls and a special type of JARs, called CAP files, JCVM does its magic and transforms code into actions. \r\n\r\nA CAP file, the short form for \"converted applet\", represents the deliverable produces after development and it can be obtained through conversion from a .class file using specific JCDK functions.  \r\n\r\nThe new stranger here is the \"applet\" I just mentioned which, if you're either older or curious, you've probably encountered before in the web context. The applets were talking about now are not related to the web applets that don't get too much love these days. The philosophy behind them is similar, both representing a custom, standalone unit that should perform a specific task.  \r\n\r\nFor a smart card, the applet represents the programmable piece you can build and deploy. Between an applet and JCVM, there are two more layers of APIs and policies, which allow our code to run in a secure environment, without dumping core features from which a developer can benefit.  \r\n\r\nAfter an applet is developed and converted to the CAP format, the deployment phase happens. The JCRE starts by invoking the *install* method exposed by the new applet which, in response, registers itself using a dedicated *register* method. After an applet is registered, it becomes inactive, but it also becomes available for selection. \r\n\r\nWhen a client asks the JCRE to select a specific applet, and we'll see how soon enough, the applet becomes active and stays so until the \"deselect\" method is explicitly invoked or until another applet is selected. Sometimes, vendors can declare a default applet that will be automatically selected when the card is powered up.  \r\n\r\nWhile active, the applet will receive input and, using a dedicated \"process\" method as its entry point, will communicate with the client following the *application protocol data units* communication model - or, briefly, APDUs.\r\n\r\nWith APDUs entering the scene we'll be stepping once again into the mystical realm of bits and bytes, where sizes like 10 MB are each programmer's wet dream. APDU is, indeed, a byte array where each position has a conventional meaning either officially specified or appreciated by the developer.  \r\n\r\nThe structure is used for both receiving and sending variable amounts of data by making use of the standardized segmentation presented in the following table.  \r\n\r\n<div class=\"text-center\">\r\n    <img src='/images/uploads/03_01.png' description='APDU Structure' alt='APDU Structure' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Published on <a href='https://en.wikipedia.org/wiki/Smart_card_application_protocol_data_unit'>Wikipedia</a></p>\r\n</div>\r\n\r\nIf you develop a professional app, the CLA (CLASS) and INS (INSTRUCTION) bytes matter as they cannot be random. \r\n\r\nTheir values fall in a standard range, covering the description of the following command, respectively the particular instruction that shall be invoked. You can reference this table if you want to delve deeper into [ISO/IEC 7816's standardized options](https://cardwerk.com/smart-card-standard-iso7816-4-section-5-basic-organizations/), but, for our playground, choosing some available values and structuring our logical rules around them will be just fine.  \r\n\r\nDon't take it as a best practice, though, because it's not.    \r\n\r\nThe following bytes, P1 and P2 serve as input parameters for our applet, and, based on them, we can enrich the complexity of our program by addressing various possible scenarios. If the instruction is straightforward and no parameter is necessary, the general recommendation is to set them to 0x00.  \r\n\r\nThe Lc (length of command) value is strictly related to the input data, as it announces its length, and can occupy up to 2 full bytes. The maximum possible length of an input can be deduced based on this value and comes close to 65535 bytes. The actual input data starts right after the Lc position.  \r\n\r\nThe same story is available for Le (Length expected) and the output data, the only difference being that, even if the client requires a specific number of bytes, the card can change this value, based on the true length of the data it has produced.  \r\n\r\nCombining these values, we can obtain 4 scenarios that revels around data: \r\n* sending data, but expecting none in return (Lc != 0, Le == 0)\r\n* sending nothing, but expecting data in return (Lc == 0, Le != 0)\r\n* sending nothing, expecting nothing (Lc == 0, Le == 0)\r\n* sending data and expecting data in return (Lc != 0, Le != 0)\r\n\r\nThe last two bytes, SW1 and SW2, are populated during the processing step and represent the exit status of the executed command.  \r\n\r\nIf we're lucky enough, we'll encounter only *0x90 0x00*, which is the green code for *everything went well* and no unexpected exceptions were thrown, similar to a 0 status code in a classical computer program. Sometimes, or, frankly, many times, errors can arise and, even if some of the codes are just a convention, it is better to [keep their evidence](https://www.eftlab.com/knowledge-base/complete-list-of-apdu-responses/).  \r\n\r\nThis model can seem simplistic at first but is more than enough to ensure effective communication between the small card processor and the outside world.  \r\n\r\nLet's remember once again that a card is not expected to download the last season of our favorite show.  \r\n\r\nHowever, who knows what the future holds?  \r\n\r\nA modern smart card can contain multiple applets and many of them can be active at the same time leveraging the [logical channels infrastructure](http://www.ruimtools.com/doc.php?doc=chapter2_lc).  \r\n\r\nThe first instinct would be to compare this feature with multithreading but, in reality, this is not the case, as the applets selected in different channels keep their state, but don't execute at the same time.  \r\n\r\nIf an applet implements the [MultiSelectable interface](https://docs.oracle.com/en/java/javacard/3.1/guide/selection-multiselectable-applets.html#GUID-711D0B18-8C80-4153-B3BD-625C2F7027B6) it can also be selected multiple times in different channels and create complex interactions with other applets.  \r\n\r\nWe won't be playing with channels today, as they are interesting enough to be considered a discussion topic on their own, so it is worth knowing that, when a card boots up, the principal channel is selected by default. This spares us a lot of trouble!    \r\n\r\nBesides channels, there are contexts, a concept that separates the applets to achieve a higher level of security.  \r\n\r\nWhenever a new applet is installed, it's placed in an applet context and then in a group context together with the other applets that share the same package.  \r\n\r\nBetween each group context, an embedded firewall mechanism prevents the communication to avoid unintended interactions. The static objects and methods can be viewed as an exception, as they are accessible for all the applets existing in the same group context.  \r\n\r\nIf data exchange between two applets is desired and an object has to be shared between different contexts, the class sharing the object should make use of the Shareable interface. However, going back and forth to the channels, [some restrictions exist.](https://docs.oracle.com/en/java/javacard/3.1/guide/non-multiselectable-applets-and-shareable-objects.html#GUID-CCB72B74-A5F1-41B2-A2C1-630F46CF6849)\r\n\r\n#\r\n### Card programming without a card\r\nEverything is fun and interesting until we remember that we don't own a card on which we can apply the things we've just learned!   \r\n\r\nEven if we kept an expired card in our closet, how are we supposed to connect it to a PC and start talking to it without some hardware magic to have our back?  \r\n\r\nWell, the truth is we can't.  \r\nNot directly with a card, at least.  \r\n\r\nIt's easy to conclude that, without a way to emulate interaction with a runtime environment, learning how to program a card wouldn't be too much fun. To address this issue, [Oracle provides for free(!)](https://www.oracle.com/java/technologies/javacard-sdk-downloads.html) a set of tools, namely a card simulator and a development kit, that will set us up in mere seconds.  \r\n\r\nBesides the tools themselves, an Eclipse plug-in is also provided to create a fully-fledged development experience. \r\n\r\nEven though I consider myself a pretty huge JetBrains fan, I have to admit that the whole package is not bad that bad. I even started to become proficient using Eclipse's perspectives and shortcuts, things that, somehow, I successfully avoided until now.  \r\n\r\n\r\n\r\nAfter a new Java Card Platform project is created, the IDE will detect each change that happens in the implemented Applets and will automatically trigger the generation of the CAP file, as well as the scripts that will install the applets into the simulator.  \r\n\r\nBesides the plug-in, we can also play manually with the development kit in the CLI. No love for Linux for now, as we get Windows-only BAT implementations.  \r\n\r\nThe whole development chain is explained pretty well in the [official docs](https://docs.oracle.com/en/java/javacard/3.1/guide/using-classic-tools.html), but, for short, after the CAP files are generated from the .class files produced by the compilation step, the *scriptgen* tool verifies the output and produces a bunch of script files.  \r\n\r\nThe script files contain the actual instructions needed to install the custom applet on the simulator and are formatted as APDUs.  \r\n\r\nAnother tool, *apdutool* reads these files and send them to the simulator, *cref*, using the communication model we've seen above. The applet is created, installed, and selected, allowing us to start playing our implementation right away.  \r\n\r\nDuring the development phase, *apdutool* is, probably, the best and fastest way to ensure communication, but if we create a stand-alone client for our applet, which we'll actually do, we need a way to \"talk\" with the card on our own.  \r\n\r\nLuckily, we have some options to choose from:\r\n* [APDU I/O API](https://docs.oracle.com/en/java/javacard/3.1/guide/apdu-i-o-api.html#GUID-CE6889C1-C8E3-4B64-9613-C6F3C1302D5D) - a library that allows APDU exchanges between an application and a card accepting device, being used for both client connections and platform simulators development\r\n* [Java Card RMI](https://docs.oracle.com/en/java/javacard/3.1/guide/using-java-card-rmi.html) - follows the model defined by the Java Remote Method Invocation model where the execution of a method is remotely invoked by a client and takes place in the card's chip\r\n* [SMARTCARD I/O API](https://docs.oracle.com/javase/8/docs/jre/api/security/smartcardio/spec/) - a newer library which allows a Java application to communicate directly with a connected smart card using the APDU model \r\n\r\nWe don't have a card - this was the first issue - so we can't directly connect to one using the last option.  \r\n\r\nThe RMI approach adds a supplementary level of abstraction which can be quite nice but strips away the necessity to understand how APDUs work. We're doing this to learn, so giving up on one of the fundamental structures in the whole smart card architecture doesn't sound too appealing.  \r\n\r\nThe last option, and, inevitably, the one we'll play with soon enough, is the APDU I/O API which allows the establishment of a quick and clean connection to the *cref* emulator.  \r\n\r\nA nice example that I've found very, very useful when I was implementing my solution was this [project](https://github.com/GillesC/labo_veilige_software_2), which demonstrates how a decoupled implementation can be achieved, allowing the application to exchange information with an actual card or with an emulator with just a few changes.  \r\n\r\n#\r\n### What we're missing out\r\n\r\nThe theory is almost over: we've successfully covered the basics of JCRE!  \r\nThis is good news, but it's also bad ones because, as I've just said, those are just the basics of JCRE.  \r\n\r\nDeveloping a smartcard application is not equivalent to designing and implementing a fully functional e-payment infrastructure. Let's also not forget that we're talking about money: security should come first, with no compromise, while blazing fast experience for the end-user should also be provided!  \r\n\r\nThe actual implementation is, from my point of view, the fun and easy part.  \r\n\r\nFor something this big to work seamlessly, a lot of effort was required to establish failproof procedures and secured mechanisms. The card itself should be universal and tamperproof both hardware and software-wise. \r\nThe global network that holds everything together should be the same and, more so, should work all day, every day.  \r\n\r\nMore and more complex problems start to arise if we stop and think about it for a second.  \r\n\r\nThe idea behind this article is to get familiar with the means of card programming - which, thanks to Sun and, later, to Oracle are not extraordinary hard if we look just at the basics.  \r\n\r\nBesides the basics, though, if we think about implementing a security scheme and the protocols required to ensure a secure transaction, a certificate validation process between a card and a payment terminal, an inter-bank communication procedure - it's more than a lot.  \r\n\r\nIf you're interested in this topic, there's a long way ahead, so don't change your LinkedIn title to *\"Java Card Programmer\"* just yet!  \r\n\r\n#\r\n### Everything is better encrypted\r\n\r\nExcept for passwords. :)  \r\n\r\nJokes aside, in software terms security is many times associated with encryption and, even though it's a fairly simplistic view, it's kind of true.  \r\n\r\nAs I've mentioned in the beginning, I didn't stumble upon Java Card programming during my procrastination routine. As usual, a course wouldn't be complete without a project, and, in my case, I chose to build a card applet that encrypts and decrypts files using AES.  \r\n\r\nEven though encryption is a common auxiliary topic in card programming, encrypting a whole file is not representative of what a card should do in a typical context. We're talking about full encryption, not digital signatures, or something in between, but it's a nice example to get ourselves accustomed to how a practical problem can be approached using this type of technology.  \r\n\r\nIf you're not familiar with AES, it's an acronym that stands for [*Advanced Encryption Standard*](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) and it became the current standard for symmetric encryption in 2002 after it won a public competition and replaced the already broken DES and its 3DES successor. It operates on 128 bits, but has multiple flavors for its key size, starting from 128 bits up to 256.    \r\n\r\nI'm not going to give more details about how the algorithm works, but you can check [this video](https://www.youtube.com/watch?v=O4xNJsjtN6E) if you want to develop a better understanding.  \r\nDr. Mike Pound is awesome, isn't he?  \r\n\r\nNow, besides its specific sizes, a block algorithm can be implemented using different modes of operation. [Another charming explanation delivered right here](https://www.youtube.com/watch?v=Rk0NIQfEXBA).  \r\n\r\nFirst of them is ECB, the Electronic Code Book, which has a fancy name, but, in reality, it represents the basic way of applying encryption: you take one block, you encrypt it, you're done.  \r\n\r\nThe problem with ECB is that identical blocks encrypted with the same key will be the same, thus many attacks become possible. The following picture, an encrypted version of Tux, speaks for itself.  \r\n\r\nIt's pretty convenient that we learned something about images in the [previous article](https://encapsulated.dev/blog/the-art-of-hiding), doesn't it? \r\n\r\n<div class=\"text-center\">\r\n    <img src='/images/uploads/03_02.png' description='Encrypted Penguin' alt='Encrypted Penguin' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Published on <a href='https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)'>Wikipedia</a></p>\r\n</div>\r\n\r\nIt's easy to observe why ECB is not used anymore, but let's take a look at CBC, the Cipher Block Chaining mode, whose properties will make our beloved penguin unrecognizable, as you can see in the last picture.  \r\n\r\nCBC adds a new layer of complexity by making use of a new concept, named initialization vector, or IV. When the first block is encrypted, before it enters the AES pipeline, it's [XORed](https://en.wikipedia.org/wiki/Exclusive_or) with the IV, adding a twist to our data.  \r\n\r\nThe second block will follow the same operation, but, instead of IV, the encrypted value of the previous block is used, thus the \"chaining\" qualification in its name. This way, two identical blocks will depend on the previous block, dramatically reducing the probability of reaching the same value.  \r\n\r\nIt's also important to know that this addition doesn't shift the strength of the algorithm in the IV, as it's not a secret. When we decrypt something, though, we need to know it, together with the password, so we can apply the same process in reverse.  \r\n\r\nIf you've watched the whole video I recommended above, you know by now that more sophisticated modes of operation exist, like CTR or CFB, but CBC is still used in some well-defined scenarios. I opted for it because, unlike ECB, it's not a completely bad practice. \r\n\r\nProbably a more deciding factor, though, is the fact that is, currently, the only mode of operation [supported by the simulator](https://docs.oracle.com/en/java/javacard/3.1/guide/supported-cryptography-classes.html#GUID-0F2BEB9A-5BB0-4908-926D-BB39672B8095).   \r\nI can say that it wasn't the toughest choice I ever made.  \r\n\r\nNow, when we're talking about cipher algorithms, another important concept that comes into play is *padding*.  \r\n\r\n#\r\n### To pad or not to pad\r\n\r\nEach block cipher algorithm has a block size representing the number of bits that can be processed at once by the underlying algorithm. Just like we saw in its description, AES has a 128 bits block size or, if it's easier to visualize, 16 bytes.  \r\n\r\nIn a perfect world, each message we wish to encrypt would have a size divisible by 16 and we won't spend time talking about the notion of padding. In practice, though, this doesn't happen very often, so padding is required to extend the size of a block to 16.  \r\n\r\nThe simplest type of padding is, obviously, no padding, when we make sure that our message has a compatible size.   \r\n\r\nA little more complex, yet still simple way is to add zeroes until the condition is satisfied. If we're unlucky, though, and our message already ends with a bunch of zeroes, the *zero-padding* is not a suitable idea, as we won't be able to tell, in a programmatic way, what to discard and what to keep.  \r\n\r\nThe most common and failproof technique and also the one we'll *implement* soon is called PKCS7 and, even though it's a pretty serious standard, it's surprisingly easy to understand. The following picture should be more than enough, even if you're not used to bits, bytes, and hexadecimal representations.\r\n\r\n<div class=\"text-center\">\r\n    <img src='https://upload.wikimedia.org/wikipedia/commons/c/c2/Padding_en.png' description='PKCS7 Padding' alt='PKCS7 Padding' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Published on Wikipedia</p>\r\n</div>\r\n\r\nA picture really speaks for itself.  \r\n\r\nWe compute how many padding bytes are needed and add the obtained value until the block is complete. If we already have a complete block, to avoid uninformed removals that could produce incorrigible errors, we add a full block that contains in each value its block size length.   \r\n\r\nThe only downfall, if it can be considered one, is that, if our final block is complete, our encrypted message will be bigger than the original message with one block: the padding. This may be a problem in low-level systems, where saving up each bit is a holy grail, but for modern systems, including cards, we are more than safe.   \r\n\r\n**We talked a lot. Let's wrap it up: we'll encrypt our message, which will actually be a file, using AES in CBC mode, with PKCS7 compliant padding.** \r\n\r\n<div class=\"text-center\">Nice!</div>\r\n\r\n#\r\n### Defining our conventions\r\nThe last thing we need to establish before jumping into the IDE is the conventional values we will associate with each operation.  \r\n\r\nFor our app to work in normal *parameters*, it has to receive a key, encrypt or decrypt a block and, for safety, remove an already loaded key.  \r\n\r\nMore so, the memory available into a card is small, smaller than a typical file that we're using today: we'll split the content into chunks and find a way to encrypt each one. The problem, now, is that, even if our card will be able to apply PKCS7 on its own, it cannot guess if a block is the first or the last one.  \r\n\r\nKnowing these situations, we can determine some conventional rules by juggling with the INS and P1 bytes present in the header of each APDU.  \r\n\r\nFor the INS byte, which defines what instruction we want to be executed, we can use, according to the standard, [only even values that don't start with *6X* or *9X*.](https://cardwerk.com/smart-card-standard-iso7816-4-section-5-basic-organizations/)  \r\n\r\nTo keep it simple, I settled for the next values:\r\n* 0x50 - set password\r\n* 0x52 - encrypt chunk\r\n* 0x54 - decrypt chunk\r\n* 0x56 - remove password\r\n\r\nThe last block scenario will be handled by the P1 parameter. If its value is equal to 1, it means that there's more data to come. If it's equal to 0, the block we're currently sending is the last in our entire file.  \r\n\r\nFor CLA we'll be using [0x80](https://stackoverflow.com/questions/34929164/what-exactly-is-the-class-byte-in-javacard), an available value which won't influence our example, and P2 will remain 0 during the whole communication process.  \r\n\r\n#\r\n### Getting jiggy with it\r\nWe're finally starting to write some code!\r\n\r\n```java\r\n@StringPool(value = { @StringDef(name = \"Package\", value = \"eu.ase.jcard\"),\r\n        @StringDef(name = \"AppletName\", value = \"MyApplet\") }, name = \"MyAppletStrings\")\r\npublic class MyApplet extends Applet {\r\n    private static final short BLOCK_SIZE = 16;\r\n\r\n    private AESKey key;\r\n    private Cipher cipher;\r\n    private byte[] previousBlock;\r\n    private byte[] data;\r\n}\r\n```\r\n\r\nOur applet definition is as basic as it could get and even its name says so!  \r\n\r\nThe attributes we're defining here will be used in various places during the processing phase. The card has a limited amount of memory and doesn't make use of a garbage collector, so we'll be using the dataSize parameter to indicate how many useful bytes we set in our data buffer, instead of allocating it every time we change its content.  \r\n\r\nThe *previousBlock* byte array will be used to store the value of the last encrypted block that was processed, which will be used as IV for the following sequence. We've also defined a *static final* variable, BLOCK_SIZE, to avoid filling our program with flying *16*. \r\n\r\n```java\r\npublic static void install(byte[] bArray, short bOffset, byte bLength) {\r\n    new MyApplet().register();\r\n}\r\n```\r\n\r\nThe install method is called during the installation phase of our applet on the smart card. Right after the applet is instantiated, it fires the following standard step: registration. After the registration is finished, our applet becomes selectable for potential clients.   \r\n\r\n```java\r\nprotected MyApplet() {\r\n    this.key = null;\r\n    this.cipher = Cipher.getInstance(Cipher.ALG_AES_BLOCK_128_CBC_NOPAD, false);\r\n\r\n    this.data = JCSystem.makeTransientByteArray((short) 128, JCSystem.CLEAR_ON_RESET);\r\n    this.previousBlock = JCSystem.makeTransientByteArray(BLOCK_SIZE, JCSystem.CLEAR_ON_RESET);\r\n\r\n    Util.arrayFillNonAtomic(this.previousBlock, (short) 0, BLOCK_SIZE, (byte) 0x00);\r\n}\r\n```\r\n\r\nWhen the applet is instantiated, we initialize its attributes as well.  \r\n\r\nThe big difference here, compared to a Java SE common instantiation, is the call to the JCSystem.makeTransientByteArray method which is the direct equivalent to the \"new\" keyword in a normal context and creates a new instance in the RAM space.  \r\n\r\nIf we were to instantiate a new object with *new*, things would work out fine, but, the object would be created inside the EEPROM space, which is nonvolatile, and has a limited number of rewrites.  \r\n\r\nWe're looking for normal variables, so we'll take a *byte* from the smartcard's RAM.  \r\n\r\nInteresting, too, is the fact that we're asking for a NO_PAD version of the AES-128-CBC algorithm, which, in the simulator's environment, is the best thing available, as it doesn't provide PKCS7 off the box. We'll address this problem later when we'll implement our favorite padding algorithm from scratch.  \r\n\r\nThe last thing that can catch your eye in the constructor is the sizes dedicated to each byte array.  \r\n\r\nThe previous block will hold a typical AES block, so it is easy to interpret its size, but the 128 bits allocated to the data attribute may seem strange at first.  \r\n\r\nAs we stated before, we cannot fit a reasonably sized file in the memory of our card, being it RAM or EEPROM, so we should split the content and process each chunk one by one.  \r\n\r\nThat's clear, but why **128**?  \r\n\r\nThe answer is given by the APDU structure and a few hours of experimenting blindly with different sizes.  \r\n\r\nMaybe more than a few.  \r\n\r\nAccording to the extended APDU format, we could crunch more than 128 bits of data into a single structure, but, if we want to read it or send it we have to call additional methods that would have complicated the things more than they already are. Receiving and responding with more data would improve, indeed, the execution time as the bottleneck of our entire system is the information exchange process between the client and the card.  \r\n\r\nEven though the magical number here is 128, the maximum length of the input data will be 112, to avoid the scenario where a final, 128 bits chunk is received, resulting in a 144 bits response that will overflow our APDU.  \r\n\r\nA little sacrifice to avoid further complications!\r\n\r\nBefore the constructor returns, we fill the previousBlock attribute with zeroes, obtaining our IV.  \r\nLazy approach, I know, but it won't bother us too much for now.  \r\n\r\nAfter the applet is instantiated, it's ready to be selected and exchange APDUs! \r\n\r\n```java\r\n@Override\r\npublic void process(APDU apdu) {\r\n    if (selectingApplet()) {\r\n        return;\r\n    }\r\n\r\n    byte[] buffer = apdu.getBuffer();\r\n    switch (buffer[ISO7816.OFFSET_INS]) {\r\n    case (byte) 0x50:\r\n        setKey(buffer, apdu.setIncomingAndReceive());\r\n        break;\r\n    case (byte) 0x52:\r\n        this.processMessage(apdu, Cipher.MODE_ENCRYPT);\r\n        break;\r\n    case (byte) 0x54:\r\n        this.processMessage(apdu, Cipher.MODE_DECRYPT);\r\n        break;\r\n    case (byte) 0x56:\r\n        this.removeKey();\r\n        break;\r\n    default:\r\n        ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n    }\r\n}\r\n```\r\n\r\nEach command received by a selected applet, even the \"select\" request, will invoke the process method.  \r\n\r\nIf the current request is the selecting one, we use an early return to end the call, as we don't have anything to process yet. After that, according to the CLA values we've conventionally established before, we decide which action we should take.  \r\n\r\nNaturally, the first step is to create a new key based on a password chosen by the client.  \r\n\r\n```java\r\nprivate void setKey(byte[] buffer, short len) {\r\n    if (len != BLOCK_SIZE) {\r\n        ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    }\r\n    \r\n    byte[] password = JCSystem.makeTransientByteArray((short) BLOCK_SIZE, JCSystem.CLEAR_ON_RESET);\r\n    Util.arrayCopy(buffer, ISO7816.OFFSET_CDATA, password, (short) 0, BLOCK_SIZE);\r\n\r\n    this.key = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES, KeyBuilder.LENGTH_AES_128, false);\r\n    this.key.setKey(password, (short) 0);\r\n}\r\n```\r\n\r\nIf the size of the received password is other than 16 bytes, we will throw an error.  \r\n\r\nAES indeed supports 160 and 256-bit keys besides the 128 ones, but, sadly, the simulator [supports only the smallest one](https://docs.oracle.com/en/java/javacard/3.1/guide/supported-cryptography-classes.html#GUID-0F2BEB9A-5BB0-4908-926D-BB39672B8095)  \r\n\r\nAfter the length is verified, we do nothing more than extracting the password from the incoming buffer and setting it in a local variable which is used to initialize a new AESKey.  \r\n\r\nThe client will know if the operation was successful by consulting the values of the status bytes.  \r\n\r\nFrom our point of view, the password is set: the job's done.  \r\nIt's time to talk about real work.  \r\n\r\n```java\r\nprivate void processMessage(APDU apdu, byte mode) {\r\n    boolean lastBlock = ((apdu.getBuffer()[ISO7816.OFFSET_P1] & 0x01) == 0);\r\n    short length = apdu.setIncomingAndReceive();\r\n\r\n    if (this.key == null) {\r\n        ISOException.throwIt(ISO7816.SW_DATA_INVALID);\r\n    }\r\n\r\n    updateChunk(apdu.getBuffer(), ISO7816.OFFSET_CDATA, length, lastBlock, mode);\r\n    sendResponse(apdu);\r\n}\r\n```\r\n\r\nThe *processMessage* method does all the heavy lifting, being the entry point to both encryption and decryption, according to the mode parameter. \r\n\r\nWe start by checking the P1 byte and concluding if we hit the last block or just a regular one and extract the length of the received chunk. After that, we'll update it with the corresponding AES encrypted bytes and send the response to our impatient client.  \r\n\r\nThe next thing in line is to understand how the bytes are updated and, for that, we'll take a look at the following methods.\r\n\r\n```java\r\nprivate void updateData(byte[] buffer, short dataOffset) {\r\n    Util.arrayCopy(buffer, dataOffset, this.data, (short) 0, (short) this.dataSize);\r\n}\r\n\r\nprivate void computeAES(byte mode) {\r\n    cipher.init(this.key, mode, this.previousBlock, (short) 0, BLOCK_SIZE);\r\n\r\n    if (mode == Cipher.MODE_DECRYPT) {\r\n        Util.arrayCopy(this.data, (short) (this.dataSize - BLOCK_SIZE), this.previousBlock, (short) 0, BLOCK_SIZE);\r\n    }\r\n\r\n    cipher.doFinal(this.data, (short) 0, (short) this.dataSize, this.data, (short) 0);\r\n\r\n    if (mode == Cipher.MODE_ENCRYPT) {\r\n        Util.arrayCopy(this.data, (short) (this.dataSize - BLOCK_SIZE), this.previousBlock, (short) 0, BLOCK_SIZE);\r\n    }\r\n}\r\n\r\nprivate void updateChunk(byte[] buffer, short dataOffset, short len, boolean lastBlock, byte mode) {\r\n    this.dataSize = len;\r\n    updateData(buffer, dataOffset);\r\n\r\n    if (lastBlock) {\r\n        processLastBlock(buffer, dataOffset, len, mode);\r\n    } else {\r\n        computeAES(mode);\r\n    }\r\n}\r\n```\r\n\r\nThe *updateChunk* method will update the *dataSize* attribute which will be available throughout the program with the number of bytes we've received.  Then, using the *updateData* method that is too simple to discuss, the bytes are copied from the incoming buffer in our *data* variable.   \r\n\r\nIf the current block is placed anywhere, but last, we continue by calling the *computeAES* method. Here, we initialize the cipher using our key and the values stored in the previous block, which, for the first round, will be nothing else than the IV we filled before.  \r\n\r\nThe actual AES encryption is invoked by the *doFinal* method. The result, which has always the same length as our data, is stored in the data buffer, overwriting the unprocessed version of the message.  \r\n\r\nBased on the mode parameter, the result will be either an encrypted version of the original message or its decryption.  \r\n\r\nNow, if we are to decrypt the data, it means that we are dealing with one or more encrypted blocks whose total size must be divisible with AES's block size.  \r\n\r\nDue to the CBC approach, the value of the next block we've yet to receive will be XORed with the value of the previous **encrypted* block - which is the last block in the current chunk before the *doFinal* method is called.\r\n\r\nBefore we decrypt our data, we have to store the last 16 bits in the previousBlock so we can correctly address it next time. The same thing happens during the encryption process as well, but only after the processing is finished, ensuring that the previousBlock contains the encrypted bytes and not the original message.  \r\n\r\nWhen the *computeAES* method finished, the result of our on-going operation is stored in the *data* attribute, ready to be sent over to the client.   \r\n\r\n```java\r\nprivate void sendResponse(APDU apdu) {\r\n    Util.arrayCopy(this.data, (short) 0, apdu.getBuffer(), (short) 0, (short) this.dataSize);\r\n    apdu.setOutgoingAndSend((short) 0, (short) this.dataSize);\r\n}\r\n```\r\n\r\nThanks to Java Card API, sending the response is a piece of cake. We just need to copy the processed bytes from our data buffer into the APDU and we're good to go.  \r\n\r\nThe last case we have to discuss is, probably, the most important one: handling the last block.  \r\n\r\nAs we've seen in the *updateChunk* method, if the last block flag is received, instead of directly computing AES, we invoke a method called *processLastBlock*.  \r\n\r\nPretty convenient, right?  \r\n\r\n```java\r\nprivate void processLastBlock(byte[] buffer, short dataOffset, short len, byte mode) {\r\n    if (mode == Cipher.MODE_ENCRYPT) {\r\n        applyPKCS7Padding();\r\n        computeAES(mode);\r\n    } else if (mode == Cipher.MODE_DECRYPT) {\r\n        computeAES(mode);\r\n        removePKCS7Padding();\r\n    }\r\n   \r\n    Util.arrayFillNonAtomic(this.previousBlock, (short) 0, (short) 16, (byte) 0x00);\r\n}\r\n```\r\n\r\nAs expected, the actions that target the last block are directly dependent on the mode we're currently in.  \r\n\r\nIf we're encrypting, before the *computeAES* method does its magic on the chunk containing the last block, we need to calculate and apply the PKCS7 padding.  \r\n\r\nDuring the decryption phase, we have to the same thing, but in a different order, removing the padding after the data was processed.  \r\n\r\n```java\r\nprivate void applyPKCS7Padding() {\r\n    short quotient = (short) (this.dataSize / BLOCK_SIZE);\r\n    short remainder = (short) (this.dataSize % BLOCK_SIZE);\r\n\r\n    short offset = (short) (quotient * BLOCK_SIZE);\r\n    short length = remainder == 0 ? BLOCK_SIZE : remainder;\r\n\r\n    if (length == BLOCK_SIZE) {\r\n        Util.arrayFillNonAtomic(this.data, offset, BLOCK_SIZE, (byte) 0x10);\r\n        this.dataSize += BLOCK_SIZE;\r\n    } else {\r\n        int requiredPadBytes = BLOCK_SIZE - length;\r\n        for (short i = (short) (offset + BLOCK_SIZE); i >= offset + length; i--) {\r\n            this.data[i] = (byte) requiredPadBytes;\r\n        }\r\n        \r\n        this.dataSize += requiredPadBytes;\r\n    }\r\n}\r\n```\r\n\r\nThe first step we need to take is to determine how many bites are in the last block. This is where the constants we defined, in the beginning, come in as useful.  \r\n\r\nWe calculate the quotient and the remainder of the chunk's size in regards to the block size and, based on that, we determine the actual length. \r\n\r\nIf our last block is complete, according to the PKCS7 format, we need to append a full block with all its values equal to 16 - its length - and increase the *dataSize* with, you guessed, 1 block.  \r\n\r\nIf the last block is not complete, a scenario that will happen most of the time, we will determine the number of required padding bytes by subtracting from 16 the size of the block. \r\n\r\nThen, we loop starting from the bottom, updating the residual values in the buffer with the *requiredPadBytes* value.  \r\n\r\nIn the end, we reflect the change in our total *dataSize* through the addition of the missing bytes.  \r\n\r\n```java\r\nprivate void removePKCS7Padding() {\r\n    short encounters = 1;\r\n    byte padValue = this.data[(short)(this.dataSize - 1)];\r\n    for (short i = (short) (this.dataSize - 2); i >= 0; i--) {\r\n        if (this.data[i] == padValue) {\r\n            encounters += 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    this.dataSize -= encounters;\r\n}\r\n```\r\n\r\nThe removal procedure is a little bit shorter and simpler, as we don't, actually, remove anything.  \r\n\r\nWe know that our last block is complete, so we loop through it starting from the second-to-last element.  \r\n\r\nBefore doing so, we extract the last element, which we are sure that it's representing the padding value, and we continue to move backwards until we hit a different value.  \r\n\r\nThe only thing we have to do in the end is to decrease the size of the *dataSize* attribute with the number of encounters. This way, even though the *data* is unaltered, the bits composing the padding won't be sent back to the client.    \r\n\r\nAnd we're done!  \r\n\r\nWe successfully implemented a smartcard application that can receive and encrypt files, no matter their size.  \r\n\r\n*It's a nice effort, but, without a reliable client, can we really take advantage of it?*  \r\n\r\nYep, that's exactly what <strike>I thought</strike> my professor thought when he came up with this assignment!  \r\nThe idea, either way, is pretty good, so kudos to him! \r\n\r\nLet's move on and put together a quick and, hopefully, not so dirty client application!  \r\n\r\n#\r\n### Talking to cards\r\n\r\nThe easiest way to create a cross-platform client application is to keep the same stack we've used until now. The client must have a GUI, so I relied on Java Swing to build a simple and ugly interface that gets the work done.  \r\n\r\nIn my defense, I'm a backend developer who tries to create beautiful UIs... and I think that's enough to help you visualize the result without even seeing it.  \r\n\r\nJokes aside, the final result looks like this\r\n\r\n<div class=\"text-center\">\r\n    <img style=\"margin: 0 auto\" src='/images/uploads/03_03.png' description='Client application GUI' alt='Client Application GUI' >\r\n    <p style=\"margin-top:0px;font-size:12px;\">Client Application GUI</p>\r\n</div>\r\n\r\nand I think it's pretty intuitive, even though a web designer will probably hit me with the Material Design Manifesto for saying so.  \r\n\r\nThe most important thing regarding our client app is how it can communicate with the applet we've just installed on our simulator.  \r\n\r\nWell, not quite installed.  \r\n\r\nWe've written the code and the tools generated a bunch of *script* files that need to be loaded in the simulator. To build a stand-alone application, the fastest way is to install the applet right after the client app boots up and make it invisible to the final user.  \r\n\r\nI've split the app into multiple classes, each one operating with a particular concept: \r\n* JCardManager - handles the whole communication process with the card, using the APDU I/O library  \r\n* IOManager - manages the interaction between our application and the file system, allowing us to read documents in chunks and keeping the state of the involved streams  \r\n* ByteUtils - provides the means to transform the initial scripts from the string representation of hex values to actual byte arrays  \r\n* MainPanel - builds the UI and coordinates the interactions between the two *managers*  \r\n\r\nLet's start with the part most specific to our article: the APDU exchange process.  \r\n\r\nThe JCardManager class looks like this, in terms of attributes and constructors.\r\n\r\n```java\r\npublic class JCardManager {\r\n    private int port = 9025;\r\n    private String address = \"localhost\";\r\n\r\n    private boolean initialized = false;\r\n\r\n    private AESMode mode;\r\n\r\n    private CadClientInterface cad;\r\n    private Socket socket;\r\n    private InputStream is;\r\n    private OutputStream os;\r\n\r\n    public JCardManager() throws UnknownHostException, IOException, CadTransportException {\r\n        initializeConnection();\r\n    }\r\n\r\n    public JCardManager(String address, int port) throws UnknownHostException, IOException, CadTransportException {\r\n        this.address = address;\r\n        this.port = port;\r\n        initializeConnection();\r\n    }\r\n```\r\n\r\nThe *CadClientInterface* is used to directly communicate with our simulator, but, in order to work, it needs access to input and output streams connected to the port where the simulator is listening. This automatically implies a socket. The default port where the simulator awaits new connections is 9025 and is the default value we've also defined.  \r\n\r\nThe AESMode is a simple enum I've built to establish which operation available on the card should be invoked: remember the 4 scenarios we've presented before we've started coding.  \r\n\r\nDuring the instantiation process, both constructors invoke the *initializeConnection* method which opens a connection to the card, as you can see below. \r\n\r\n```java\r\nprivate void initializeConnection() throws UnknownHostException, IOException, CadTransportException {\r\n    this.socket = new Socket(address, port);\r\n    this.is = socket.getInputStream();\r\n    this.os = socket.getOutputStream();\r\n\r\n    cad = CadDevice.getCadClientInstance(CadDevice.PROTOCOL_T1, is, os);\r\n    cad.powerUp();\r\n}\r\n\r\npublic void closeConnection() throws IOException, CadTransportException {\r\n    if (initialized) {\r\n        cad.powerDown();\r\n        os.close();\r\n        is.close();\r\n        socket.close();\r\n        initialized = false;\r\n    }\r\n}\r\n```\r\n\r\nIt's a best practice to clean after yourself, a thing that it's done in the symmetric *closeConnection* method.  \r\n\r\nAfter the connection is initialized, our application can proceed and install our applet using the scripts generated by the *scriptgen* tool.  \r\n\r\n```java\r\npublic void loadScripts() throws IOException, CadTransportException, JCardException {\r\n    List<String> commands = IOManager.loadInitScript();\r\n\r\n    this.initialized = true;\r\n\r\n    for (String s : commands) {\r\n        exchangeCommand(ByteUtils.hexArrayToByteArray(s));\r\n    }\r\n}\r\n```\r\n\r\nA line in such a script looks like this:\r\n\r\n```\r\n0x80 0xB4 0x07 0x00 0x20 0x07 0x02 0xD4 0x00 0x02 0x30 0x8F 0x00 0x07 0x3D 0x8C 0x00 0x13 0x8B 0x00 0x08 0x7A 0x04 0x10 0x18 0x8C 0x00 0x09 0x18 0x10 0x0D 0x03 0x8D 0x00 0x0A 0x87 0x00 0x7F\r\n```\r\n\r\nand it's, indeed, a string representing some bytes in their hexadecimal format.  \r\n\r\nWe rely on the *loadInitScript* method from our IOManager to read the content. You can check the source code if you want to see its implementation, but it's nothing more than a basic read-from-file.  \r\n\r\nWith the script in memory, we can start to parse it and transform the string representation of a byte in the actual byte value. This operation is leveraged in the ByteUtils class, and, same as with the *loadInitScript* method, it implements a common practice of transformation.  \r\n\r\nWe'll skip it, but I won't forget to leave a link at the end where you can check it if you want.  \r\n\r\nThe *commands* list includes each APDU we need to pass to our simulator to successfully install our applet. We'll take each of them and pass it as a parameter for the *exchangeCommand* method.  \r\n\r\n```java\r\n    public byte[] exchangeCommand(byte[] message) throws IOException, CadTransportException, JCardException {\r\n        Apdu apdu = new Apdu();\r\n\r\n        if (initialized) {\r\n            apdu.command = Arrays.copyOfRange(message, 0, 4);\r\n            apdu.setDataIn(Arrays.copyOfRange(message, 5, 5 + message[4]), message[4]);\r\n            apdu.setLe(127);\r\n\r\n            cad.exchangeApdu(apdu);\r\n        } else {\r\n            throw new JCardException(\"The card was not initialized\");\r\n        }\r\n        \r\n        if (apdu.sw1sw2[0] != -112 || apdu.sw1sw2[1] != 0) {\r\n            throw new JCardException(\r\n                    \"The card returned an error code: \" + String.format(\"%02X %02X\", apdu.sw1sw2[0], apdu.sw1sw2[1]));\r\n        }\r\n\r\n        return apdu.dataOut;\r\n    }\r\n```\r\n\r\nHere, magic happens.  \r\n\r\nWe create a new APDU and, if the card was initialized before, we start building it using the suitable bytes we've received.  \r\n\r\nThe first 4 bytes represent the header, CLA - INS - P1 - P2.  \r\n\r\nThen, we add the content of the input buffer and its size and we set the expected length as a generic 0xFF (127).  Remember that this value can be overwritten by the card depending on how many bytes the response data is composed of.  \r\n\r\nWhen everything is set, we call the *exchangeApdu* command, which represent the exact point where communication happens and, if the status flags are 0x90 (-112) and 0x00 (0), it means that no errors occurred and we can safely return the output data to the caller.  \r\n\r\nWe've covered the ideal scenario in which the APDU is already formatted.\r\nWhen we're reading plain bytes from a file, this won't be the case, and 2 auxiliary methods are needed.\r\n\r\n```java\r\nprivate byte[] buildHeader(boolean lastBlock) {\r\n    byte[] header = new byte[4];\r\n    header[0] = (byte) 0x80;\r\n    header[1] = (byte) 0x50;\r\n\r\n    switch (this.mode) {\r\n    case SET_PASSWORD:\r\n        break;\r\n    case ENCRYPT:\r\n        header[1] = (byte) 0x52;\r\n        break;\r\n    case DECRYPT:\r\n        header[1] = (byte) 0x54;\r\n        break;\r\n    case RESET_PASSWORD:\r\n        header[1] = (byte) 0x56;\r\n        break;\r\n    }\r\n\r\n    header[2] = lastBlock ? (byte) 0x00 : (byte) 0x01;\r\n    header[3] = (byte) 0x00;\r\n    return header;\r\n}\r\n\r\npublic byte[] prepareCommand(byte[] message, boolean lastBlock) {\r\n    if (message == null) {\r\n        message = new byte[] { 0x00 };\r\n    }\r\n        byte[] command = new byte[5 + message.length];\r\n\r\n    byte[] header = buildHeader(lastBlock);\r\n    for (int i = 0; i < 4; i++) {\r\n        command[i] = header[i];\r\n    }\r\n\r\n    command[4] = (byte) message.length;\r\n\r\n    for (int i = 0; i < message.length; i++) {\r\n        command[i + 5] = message[i];\r\n    }\r\n\r\n    return command;\r\n}\r\n```\r\n\r\nThe *prepareCommand* method receives the bytes of data that need to be wrapper as an APDU and a boolean indicated if the current chunk is the last one.  \r\n\r\nWe compute the length of the APDU, including the 4 bytes of header, the Lc byte, and the actual length of data, then we rely on the *buildHeader* method to generate a suitable header based on the mode that's currently set and the *lastBlock* flag.  \r\n\r\nThe Le parameter is not handled here, because, as we've seen above, it will be generically set during the *exchangeCommand* call.  \r\n\r\nThe rest of the classes are pretty bulky and are not directly related to smartcards or their associated interfaces, as they handle auxiliary processes.  \r\n\r\nSome of them may have interesting implementation details, but from all of them, I would like to explain one more, which will encapsulate a detail we've discussed during the applet development.   \r\n\r\nGood.  \r\n\r\nYou probably remember that, even though AES accepts 3 different key sizes, we limited our implementation to keys of 128 bits, constrained by the fact that this is the only implementation supported by the simulator.  \r\n\r\nStill, requesting a password of exactly 16 characters is not something we can ask from our user without assuming that he's going to roll his eyes.\r\n\r\nTo make things easier we can take its initial input, no matter the size, and apply a key derivation function to produce a complex, randomized password, based on the current hashing standard, SHA-256.  \r\n\r\nThis way, the user can give us any password he likes without being constrained by the fixed size imposed by our AES program. After applying a KDF on the input we can obtain a new password that respects our length condition and it's resistant to brute-force.  \r\n\r\nThe most modern KDF implementation is Argon2, but, for learning experiments, PBKDF2 is more than safe.  \r\n\r\n```java\r\nprivate byte[] getDerivedPassword(String password) {\r\n    byte[] derivedKey = null;\r\n\r\n    try {\r\n        // in a typical system the salt should be stored\r\n        byte[] salt = \"salt\".getBytes();\r\n        \r\n        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 10000, 128);\r\n        SecretKeyFactory f = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\r\n\r\n        derivedKey = f.generateSecret(spec).getEncoded();\r\n    } catch (NoSuchAlgorithmException e) {\r\n        showToast(\"PBKDF2WithHmacSHA256 is not supported\");\r\n        System.exit(-1);\r\n    } catch (InvalidKeySpecException e) {\r\n        showToast(\"Invalid KeySpec\");\r\n        System.exit(-1);\r\n    }\r\n\r\n    return derivedKey;\r\n}\r\n```\r\n\r\nThe rest of the implementation covers basic Java programming, a little bit of multithreading, questionably positioned Swing controls and a mechanism to handle input and output files using chunks small enough to avoid RAM abuse, but big enough to be kinda efficient.  \r\n\r\nIf you're curious or want to implement something similar, you can find the integral implementation [here]().  \r\n\r\nThank you for coming so far!  \r\n\r\nWhen you go outside and pay for something good, remember that your little wallet companion comes to life for a fraction of a second!  \r\n\r\n<div class=\"text-center\">\r\n    <bold><h3>See you next time</h3></bold>\r\n</div>",
  "seoDescription": "Like many of us, I started dumping cash a few years ago and I paid almost exclusively with one of my cards. I'm not gonna lie, sometimes I was a little curious about how the transaction is executed, but I was not curious enough to dig deeper. "
}