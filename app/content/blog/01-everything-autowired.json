{
  "publishedAt": "28th April 2020",
  "title": "01 - Everything @Autowired",
  "content": "Even though it felt out of grace since the constructor injection became a best practice, the @Autowired annotation is still worth reviewing.\n\nIf you've wondered how a single word can inject a whole class with its mere presence: **gotcha**. \n\nThe @Autowired annotation is the perfect introduction to metaprogramming.\n\n<div class=\"text-center\">\n    <img src='/images/uploads/01_01.jpg' description='' >\n    <p style=\"margin-top:0px;font-size:12px;\">Photo by <a href='https://unsplash.com/@maximilianweisbecker'>Maximilian Weisbecker</a></p>\n</div>\n\n### Annotations overview\n\nFirst of all, an annotation is used to mark up classes, fields, parameters, or methods, allowing us to check for their presence in some particular conditions.\n\nA basic annotation implementation looks like this and it fairly resembles an interface.\n\n```java\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CustomAnnotation {\n    int value() default 0;\n}\n```\n\nIf the first thing that went through your head was why the annotation is annotated, it's ok, I thought the same thing.\\\nBesides, being a special type of interface, an annotation can have its own attributes, but in a form that resembles methods.\\\nYou can find a nice intro to [annotations here](https://www.baeldung.com/java-custom-annotation). \n\nAnyway, the most common annotations you'll find on custom annotations are:\n\n* [@Target](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html) specifies what structures the annotation will target. As I mentioned before parameters, classes, methods, and fields can be annotated, but Packages can be annotated too!\n* [@RetentionPolicy](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/RetentionPolicy.html) declares how much the annotation will be available before it's dropped. It can be kept during the runtime, discarded by the VM, or not written in the .class file at all.\n* [@Repeatable](https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html) which allows an annotation to be placed multiple times on the same entity \n\nAn annotation does not affect the behavior of our code in any way, but they help us identify how a part of a class should be treated.\n\n### Enter: Annotation Processing.\n\nAs its name made it obvious, annotation processing is the step where the annotation will finally seem valuable.\n\nThere are many ways an annotation processor can be implemented, the most popular being:\n\n* the actual [Annotation Processing API](https://www.baeldung.com/java-annotation-processing-builder) introduced in Java 8\n* Bytecode manipulation \n* clever hacks - if you've heard of the Lombok project, the [creators implemented a smart hack](http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html) using an unpublished API of the Java compiler which allows AST changes so the classes that are marked using a specific annotation can be modified)\n* processing annotations at runtime using Java Reflection\n\nThe last technique is also the one we will use to implement our spin of the @Autowired annotation.\n\n### Writing the code\n\nFirst, we'll define our special annotation that will act like @Autowired but will be defined as a type-level annotation, so we'll use it on top of our class instead of our attributes.\n\nWhy? \n\nBecause an exact copy of the @Autowired wouldn't be so cool.\\\nPlus, it, for sure, seems more magical than a regular field annotation and will help us visualize exactly how powerful the Java Reflection API is.\n\nAnd, because we're very original, let's call it @ManagedClass.\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface ManagedClass {\n}\n```\n\nBesides the type-level annotation, we also defined it as a class retention annotation.\nWhy? I'll explain later.\n\n#### Next, we need a context. It's time for some creativity.\n\nLet's suppose we have a cat that's not so playful with young people. Each time we try to pet it, the chance we'll get a scratch decreases with our age, but is also dependent on the cat's disposition to be petted. It's a fact that cats are moody so making this awful generalization is not that far from the truth. (Disclaimer: I have a cat)  \n\nThe Human class\n\n```java\npublic class Human {\n    private int age;\n    private Cat cat;\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void pet() {\n        String result;\n        result = cat.calculateDisposition(age) > 10 ? \"Auch! This surely hurt!\" : \"The cat seems to like you!\";\n        System.out.println(age + \": \" + result);\n    }\n}\n```\n\n\\\nand the Cat class\n\n```java\n@ManagedClass\npublic class Cat {\n    private Random fakeRandomGenerator = new Random();\n\n    public int calculateDisposition(int humanAge) {\n        return fakeRandomGenerator.nextInt() + (int) (0.3 * humanAge);\n    }\n}\n```\n\nBecause the Human owns a Cat, we've annotated the Cat class with the @ManagedClass we've created earlier. Each time a human is instantiated, we'll somehow manage to give him \na pet without explicitly doing so.\n\nBefore we delve further, it would be nice if we'd read the official [Java Reflection trail](https://docs.oracle.com/javase/tutorial/reflect/index.html).\\\nBut, because we're running out of time and our cat needs to be petted, we'll do that later. Promise!\\\nShortly, using the Reflection API we can extract the class of an object using the .getClass() method and we'll obtain, guess what, a Class object.\\\nIf no object is available, we can also use the Class.class syntax which will return the same thing.\\\nThrough the Class object we can interrogate its methods, fields and even instantiate new objects at runtime in a more abstract way.\nWe'll play with some of them pretty soon, but, for the record, here's [an exhaustive list](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html)  you can check if you want to get more insight.\n\n<div class=\"text-center\">\n    <img src='/images/uploads/01_02.jpg' description='' >\n    <p style=\"margin-top:0px;font-size:12px;\">Photo by <a href='https://unsplash.com/@coffeegeek'>Coffee Geek</a></p>\n</div>\n\nIf you've recognized the @Autowired annotation, and I'm sure you did because you've come so far reading this article!, I'm pretty confident that you're also familiar with Java Beans.\\\nJust for the record, a bean is nothing more than a serializable class that has all its attributes private, has properly named getters and setters, and the default constructor.\\\nThe classes we defined before respect this convention.\\\nAlmost.\\\nOkay, you got me, they aren't actual beans, according to the definition, but, for simplicity, we will make an *exception*.\n\nIs it so important to follow this structure?\\\nWell, **yes** - at least some of it.\\\nBy using this pattern, we can instantiate an object right away, without dealing with its attributes, and play with them later using its accessors.\\\nThe classes our annotation processor will inspect are ready.\\\nLet's define an AnnotationManager, then!\n\n```java\npublic class AnnotationManager {\n    private Map<String, Class<?>> injectableTypes;\n    private Map<String, Object> managedObjects;\n    private static AnnotationManager instance;\n\n    private AnnotationManager() {\n        managedObjects = new HashMap<>();\n        injectableTypes = new HashMap<>();\n        initializeInjectableTypes();\n    }\n\n    public static AnnotationManager getInstance() {\n        if (instance == null) {\n            instance = new AnnotationManager();\n        }\n        return instance;\n    }\n\n    private void initializeInjectableTypes() {\n        //TO DO\n    }\n\n    private Object getInjectableValue(String className) throws Exception {\n        if (!managedObjects.containsKey(className)) {\n            Object managedObject = provideManagedObject(injectableTypes.get(className));\n            managedObjects.put(className, managedObject);\n        }\n\n        return managedObjects.get(className);\n    }\n\n    public <T> T provideManagedObject(Class<?> clazz) throws Exception {\n        Constructor<?> constructor = clazz.getConstructor();\n        Object providedObject = constructor.newInstance();\n        for (Field field : clazz.getDeclaredFields()) {\n            if (injectableTypes.get(field.getType().getName()) != null) {\n                Object injectableValue = getInjectableValue(field.getType().getName());\n                field.setAccessible(true);\n                field.set(providedObject, injectableValue);\n            }\n        }\n        return (T) providedObject;\n    }\n}\n```\n\nWoah, compared to our previous classes, this one is quite big, so we'll take it step by step, in a way that should be easy to crunch.\n\nFirst of all, you've probably observed that our class is a singleton. It's a common pattern to ensure that we have a reliable, unique source that will provide all our dependency injections.\n\nAlso, the method initializeInjectableTypes() is not yet implemented.\nBut let's not forget about it.\\\nHere we will get all the classes that are annotated using our special annotation and we will fill the injectableTypes Map, so our \nbean manager will know which classes it can provide.\nYou've probably noticed that this method is called inside the constructor. This way the map will be populated when the ClassManager is instantiated, an event that happens only once, thanks to the singleton nature we've discussed above.\n\nThe last two methods are, probably, the juiciest parts of this implementation.\\\nLet's start with provideManagedObject().\n\n```java\npublic <T> T provideManagedObject(Class<?> clazz) throws Exception {\n    Constructor<?> constructor = clazz.getConstructor();\n    Object providedObject = constructor.newInstance();\n    for (Field field : clazz.getDeclaredFields()) {\n        if (injectableTypes.get(field.getType().getName()) != null) {\n            Object injectableValue = getInjectableValue(field.getType().getName());\n            field.setAccessible(true);\n            field.set(providedObject, injectableValue);\n        }\n    }\n    return (T) providedObject;\n}\n```\n\nThis method will be called each time we want to instantiate an object that requires a dependency injection.\\\nThat's why the result is a template type - we need a way to return the class that is requested seamlessly. Inside this method, we get the constructor of our class, which is the default one, and we instantiate a new object of the class we've requested.  \\\nThe Java Reflection API is pretty straightforward and it allows access to everything we need. After that, we parse through each field of our class and check if its type is part of our injectableTypes map.\n\nWhy does it matter?\\\nBecause if it is, we need to take our role as bean manager seriously and provide an instance of that type.  \n\nThen, we proceed in asking our mysterious method, getInjectableValue, for an instance. After that, we use a little bit of reflection magic and allow ourselves to modify a field that, you're right, is technically private, and inject our freshly obtained instance. \n\n#### Metaprogramming baby!\n\nWhy did we call the getInjectableValue method and not directly instantiate the class before injecting it?\nWell, there's the beauty of it. Let's take a closer look.\n\n```java\nprivate Object getInjectableValue(String className) throws Exception {\n    if (!managedObjects.containsKey(className)) {\n        Object managedObject = provideManagedObject(injectableTypes.get(className));\n        managedObjects.put(className, managedObject);\n    }\n\n    return managedObjects.get(className);\n    }\n}\n```\n\nThe class we're trying to inject may contain another field that should be injected.\\\nWhat does this method do?\\\nFirstly, it checks, using the managedObjects map, if the required object was already instantiated for a previous request. If it didn't, it creates a new, lazy instance, puts it inside the map, and returns it.\nThe fact that we reuse the same object may seem weird, at first, but it's a common practice for the object that's injected to be the same for each injection. \n\nIn Spring, for example, we usually inject our services, our repositories, or other types of objects that can be used without depending too much on their inner state.\n\n\\\nWe didn't pick the best example to see why this is, actually, useful, but let's assume that we're passing the cat to each involved human.\n\n#### There's gonna be a lot of scratches!\n\nWe're almost ready to give it a spin, but we got one more thing to discuss: the initializeInjectableTypes method that lacks an actual implementation.\\\nPackage scanning is a complex task that can be achieved at multiple points in time during the lifecycle of a Java program.\nMost of the time, it's done at runtime by checking classes and indexing them based on the annotations that are present.\\\nHow is it done? Many implementations are relying either on direct file system scanning or using some hacks around the [URLClassLoader](https://docs.oracle.com/javase/7/docs/api/java/net/URLClassLoader.html) to provide a list with available packages.\\\nThe most popular one is Google's Reflections library that can provide exactly this functionality.\n\nWhat is the downside of this approach?\\\nThe scanning is, usually, slow and it also happens at runtime.\\\nYes, if you thought, for a second, that there's a faster approach, you're right.\n\nWe've mentioned earlier the Annotation Processing API that operates at compile time. Besides this, it can also query all the classes that are loaded and save the information gathered about them in special files that can be consulted later, at runtime.\\\nPerfect for our case. This is also the reason why the level of retention on @ManagedClass is RetentionPolicy.CLASS, instead of RetentionPolicy.RUNTIME, which is more common.\\\nThe best library that works this way is, probably, [ClassIndex](https://github.com/atteo/classindex).\\\nUsing this approach let's implement our method and annotate our ....annotation so it can be tracked by the library.\n\nAdding @IndexAnnotated on top of our own annotation\n\n```java\n@IndexAnnotated\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface ManagedClass {\n}\n```\n\n\\\nand implementing the last method using ClassIndex\n\n```java\nprivate void initializeInjectableTypes() {\n    for (Class<?> clazz : ClassIndex.getAnnotated(ManagedClass.class)) {\n        injectableTypes.put(clazz.getName(), clazz);\n    }\n}\n```\n\n\\\nLet's put it all together and write a sample that will put our code to work. A simple main will do.\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        AnnotationManager annotationManager = AnnotationManager.getInstance();\n\n        Human human = annotationManager.provideManagedObject(Human.class);\n        human.setAge(22);\n        human.pet();\n        \n        Human human = annotationManager.provideManagedObject(Human.class);\n        human.setAge(18);\n        human.pet();\n    }\n}\n```\n\nThe last thing we need to do is to run our program and see if it works.\n\n### Analyzing the results\n\n```\n80: The cat seems to like you!\n18: Auch! This surely hurt!\n```\n\nThis looks ok, but it doesn't seem so impressive with only one level of depth.\\\nLet's throw another class in play and see if our ClassManager succeeds to provide an injectable object that also requires a dependency injection.\\\nAs we observed earlier, our cat is moody. Randomly, instead of scratching us or letting us pet it, it will walk away and scratch its toy, then come back.\\\nThis being said, let's provide a scratcher implementation.\n\n```java\n@ManagedClass\npublic class Scratcher {\n    public void scratch() {\n        System.out.println(\"\\nSccccccchhh\");\n    }\n}\n```\n\n\\\nNow let's give our cat one and modify her behavior.\n\n```java\n@ManagedClass\npublic class Cat {\n   private Scratcher scratcher;\n   private Random fakeRandomGenerator = new Random();\n\n   public int calculateDisposition(int humanAge) {\n       int disposition = fakeRandomGenerator.nextInt() + (int) (0.3 * humanAge);\n\n       if (disposition % 2 == 0) {\n           scratcher.scratch();\n       }\n\n       return disposition;\n   }\n}\n```\n\nThis means that, when we'll ask the ClassManager for a human before the cat can be provided, the scratcher should, also, be injected, checking if our implementation covers this case and, virtually, any scenario that requires class nesting.\n\n```\n80: Auch! This surely hurt!\n\nSccccccchhh\n18: The cat seems to like you!\n```\n\nThat was a huge mood swing, but everything looks in check! Our method works even for multiple layers.\nWith this being said, we just concluded my first article!\nIf you want to take a closer look or change the code in any way, you can find it [here](https://github.com/axbg/encapsulated-snippets/tree/main/01-Everything-Autowired).\n\nThank you for reading!\\\nI know that this subject might not be too interesting, nor too complex, but it was pretty hard to find a first topic worth discussing. Also, I learned the hard way that article writing involves much more work than I initially thought. ðŸ˜†\n\n\\\nBut here we go.\n\n<div class=\"text-center\">\n    <bold><h3>See you next time</h3></bold>\n</div>",
  "tag": "Java Concepts",
  "seoDescription": "Even though it felt out of grace since the constructor injection became a best practice, the @Autowired annotation is still worth reviewing.",
  "seoMetaImage": "https://blog.axbg.space/images/uploads/01_01.jpg"
}
